# 인터넷 통신

메세지를 전달해야 하는 PC가 되게 멀리있다면 복잡한 인터넷 망을 통해서 전달해야 하는데 인터넷은 단순하지 않다.

수많은 노드를 거쳐서 메세지가 안전하게 거쳐가야 하는데 어떤 규칙으로 어떻게 넘겨야 잘 넘길 수 있을까에 대한 고민

# IP (인터넷 프로토콜)

> 지정한 주소(IP 주소)에 데이터를 전달할 수 있도록 규칙을 정해놓은 것

- 패킷 단위로 보내게 된다.

### IP 프로토콜의 한계?

- 비연결성
	- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
	- 서버가 죽었는지 살아있는지도 몰라도 그냥 보내버린다.

- 비신뢰성
	- 중간에 패킷이 사라지면?
		- 중간에 가다가 노드가 아예 사라지면?...
		- 광케이블이 있는데 멧돼지가 끊어먹어버리면ㅋㅋㅋㅋ?
	- 패킷이 순서대로 안오면?
		- 패킷이 가는 경로가 중간에 갑자기 바뀔 수도 있다.
		- 예측할 수가 없다

- 프로그램 구분
	- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

그래서 위의 한계를 극복하기 위해서 `TCP/UDP`이 존재한다.

# `TCP/UDP`

> IP 프로토콜의 수많은 문제점을 해결해준다.

### 인터넷 프로토콜 스택의 4계층

- 애플리케이션 계층 - HTTP, FTP
- 전송 계층 - TCP, UDP
- 인터넷 계층 - IP
- 네트워크 인터페이스 계층

TCP는 IP 계층위에 올려서 보완을 해주는 느낌이다.

### TCP 특징

> 전송 제어 프로토콜이다.

- 연결지향: 쟤랑 나랑 연결이 됐나 안됐나 확인을 하고 보낸다.
	- 저 집이 전원이 꺼져있으면 미리 방지를 할 수 있다.
- 데이터 전달 보증: 누락이 됐으면 내가 알 수 있다.
	- 응답을 받아서 확인 가능
- 순서 보장
	- 1, 2, 3 보냈는데 1, 3... 으로 도착하면?
	- 3번 버리고 2, 3번을 다시 보낸다.

신뢰성을 위한 프로토콜이고, 대부분이 TCP를 사용중이다.

### TCP 3 way handshake

> 연결을 할 때 하는 서로간의 확인 작업

1. 클라이언트에서 먼저 요청
2. 서버에서 확인 응답
3. 클라이언트에서 다시 확인
4. 그 다음 통신

근데 진짜 물리적으로 연결이 됐다는 의미는 아니다.
그냥 SYN 보내고, SYN + ACK 받고, ACK 보내면 그냥 추측상으로 "아~ 연결이 됐구나" 하고 생각하고 통신을 하는거다.
사실 중간에 엄청 많은 노드와 서버들이 존재하는데, 그냥 우리끼리만 연결됐다고 논리적으로 연결이 된 것이다. 개념적으로만 이해를 하자.

"나를 위한 랜선이 연결이 된 것이 아니다."

### UDP 특징

- 연결 지향도 안함
- 데이터 전달 보증도 안함
- 순서 보장도 안함
- IP와 거의 같은데 PORT가 추가가 됐다. 체크섬 정도가 추가 됐다.
- 애플리케이션에서 추가 작업이 필요하다.

### 그럼 왜 TCP쓰지 왜 UDP쓰냐?

TCP의 3-way-handshake는 너무 많은 시간을 소비한다.
조금 더 최적화를 하고 싶어도 하지 못한다.

그래서 TCP는 이미 손을 못 대는데, 최적화를 하고 싶으면
UDP를 사용하고 애플리케이션에서 직접 필요한 것을 구현하면 된다.

요즘 각광받고 있는데 이유는 TCP 프로토콜이 90%이상 점유를 했다.
영상을 보낼 때도 TCP를 사용하는데, 웹 브라우저에서 HTTP 통신할 때
핸드셰이킹하려면 그 과정을 다 줄여보자 해가지고 HTTP3는 UDP 프로토콜을 사용하면서 뜨고있다.

# PORT

> 배가 도착하는 항구

- 애플리케이션을 구분하는 것이 PORT다.
- 같은 IP내에서 프로세스를 구분하는 것이 PORT다.

IP가 아파트면, PORT는 몇동 몇호.
IP는 PC, PORT는 애플리케이션

0 ~ 1023은 잘 알려진 포트
0 ~ 65635까지 할당가능하다.

# DNS

> IP는 기억하기 어렵다.

전화번호부 같은 서버를 제공해준다.
IP를 쉬운 주소로 접근할 수 있게 해준다.

DNS 서버에 도메인을 등록을 해놓으면 해당 IP를 준다.

1. IP 주소는 기억하기 어렵다.
2. IP 주소가 바뀔 수 있다.

위의 두 가지를 해결해준다.
